import { exec } from "child_process";
import { promisify } from "util";
import { writeFile, unlink, readFile } from "fs/promises";
import { join } from "path";
import { tmpdir } from "os";
import { randomBytes } from "crypto";
import { storagePut } from "./storage.js";
import sharp from "sharp";

const execAsync = promisify(exec);

/**
 * Generate optimized WebP thumbnail from first page of PDF
 * Uses pdftoppm for PDF→PNG conversion, then Sharp for resize + WebP optimization
 * @param pdfBuffer PDF file buffer
 * @returns Optimized WebP image buffer
 */
export async function generatePDFThumbnail(pdfBuffer: Buffer): Promise<Buffer> {
  const tempId = randomBytes(16).toString("hex");
  const tempPdfPath = join(tmpdir(), `${tempId}.pdf`);

  try {
    // Write PDF to temporary file
    await writeFile(tempPdfPath, pdfBuffer);

    // Convert first page to PNG using pdftoppm (available on Render)
    // -f 1 -l 1: first page only, -png: output format, -singlefile: single output file
    const outputPrefix = join(tmpdir(), `${tempId}`);
    await execAsync(`pdftoppm -f 1 -l 1 -png -singlefile ${tempPdfPath} ${outputPrefix}`);
    
    // pdftoppm adds .png extension automatically
    const generatedImagePath = `${outputPrefix}.png`;

    // Read the raw PNG generated by pdftoppm
    const rawPngBuffer = await readFile(generatedImagePath);
    const rawSize = rawPngBuffer.length;

    // Optimize with Sharp: resize to max 800x600 and convert to WebP
    const optimizedBuffer = await sharp(rawPngBuffer)
      .resize(800, 600, {
        fit: "inside",
        withoutEnlargement: true,
      })
      .webp({ quality: 80 })
      .toBuffer();

    console.log(`[PDF Thumbnail] Optimized: ${(rawSize / 1024).toFixed(0)}KB PNG → ${(optimizedBuffer.length / 1024).toFixed(0)}KB WebP`);

    // Clean up the generated PNG
    try { await unlink(generatedImagePath); } catch {}

    return optimizedBuffer;
  } catch (error) {
    console.error("PDF thumbnail generation error:", error);
    throw new Error("Failed to generate PDF thumbnail");
  } finally {
    // Clean up temporary PDF file
    try {
      await unlink(tempPdfPath);
    } catch (cleanupError) {
      console.warn("Cleanup error:", cleanupError);
    }
  }
}

/**
 * Upload PDF and generate optimized WebP thumbnail, returning both URLs
 * @param pdfBuffer PDF file buffer
 * @param filename Original filename
 * @returns Object with fileUrl and thumbnailUrl
 */
export async function uploadPDFWithThumbnail(
  pdfBuffer: Buffer,
  filename: string
): Promise<{ fileUrl: string; thumbnailUrl: string }> {
  try {
    // Generate unique key for files
    const timestamp = Date.now();
    const randomSuffix = randomBytes(8).toString("hex");
    const baseKey = `market-reports/${timestamp}-${randomSuffix}`;

    // Upload PDF to S3
    const pdfKey = `${baseKey}.pdf`;
    const { url: fileUrl } = await storagePut(pdfKey, pdfBuffer, "application/pdf");

    // Generate optimized WebP thumbnail from first page
    const thumbnailBuffer = await generatePDFThumbnail(pdfBuffer);

    // Upload thumbnail as WebP to S3
    const thumbnailKey = `${baseKey}-thumbnail.webp`;
    const { url: thumbnailUrl } = await storagePut(
      thumbnailKey,
      thumbnailBuffer,
      "image/webp"
    );

    return { fileUrl, thumbnailUrl };
  } catch (error) {
    console.error("PDF upload with thumbnail error:", error);
    throw error;
  }
}
